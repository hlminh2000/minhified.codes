---
title: Async UI Prompts
date: 2025-05-18T21:38:55.297Z
preview: The powerful React pattern that lets your UI ask questions
image: "./Gemini_Generated_Image_cowdvfcowdvfcowd.png"
tags:
  - React
  - Frontend
---

# â—The Problem

Thereâ€™s a subtle but powerful React pattern that unlocks a more intuitive user experience: letting the UI ask questions. ğŸ¤”

React is declarative. We render the UI based on state. But sometimes, we need to render a *question*â€”we need to pause and ask the user for input or confirmation before continuing. Thatâ€™s where this pattern shines. âœ‹

Letâ€™s say we have a component that deletes an item:

```tsx
<button onClick={() => deleteItem(item.id)}>Delete</button>
```

But waitâ€”what if the user didnâ€™t mean to click that? Weâ€™d need a confirmation dialog, so we add one. Many of us, when building in React, opt for custom modals. But that typically means adding state directly in the current component:

```tsx
const [isModalShown, setIsModalShown] = useState(false);
const handleDelete = () => setIsModalShown(true);
const handleConfirm = async () => {
  await deleteItem(item.id);
  setIsModalShown(false);
};
```

Now we have conditional rendering for the modal, handlers for confirming or canceling, and extra state and props cluttering up the logic. The more components we do this in, the more boilerplate we end up duplicating. ğŸ˜©

With vanilla HTML, we could just call `window.confirm` and get a synchronous answer. Wouldn't it be nice if we could do something similar in Reactâ€”just `await` a modal like a function call?

# ğŸ’¡ Declarative Prompts: Letting the UI Ask

Imagine being able to *await* a modal like we would a function callâ€”clean, simple, and intuitive. âœ¨

```tsx
const confirmed = await confirm({ message: 'Are you sure?' });
if (confirmed) {
  await deleteItem(item.id);
}
```

How would this work?

This is the core idea behind **"async prompts"**â€”we render a modal declaratively, but imperatively `await` a response. Hereâ€™s a simplified example:

## ğŸ—ï¸ Step 1: Build a Local Prompt Hook

Instead of using context, we can keep everything self-contained by building a hook that manages local modal state and returns a promise. ğŸ›Œ

```tsx
// useConfirmationDialog.tsx
export const useConfirmationDialog = () => {
  const [resolver, setResolver] = useState<((confirmed: boolean) => void) | null>(null);
  const hasPending = !!resolver;

  const [title, setTitle] = useState('');
  const [bodyText, setBodyText] = useState('');
  const [loading, setLoading] = useState(false);

  const getUserConfirmation = (args: { title: string; bodyText: string }) =>
    new Promise<boolean>((resolve) => {
      setTitle(args.title);
      setBodyText(args.bodyText);
      setResolver(() => resolve);
    });

  const closeDialog = () => {
    setLoading(false);
    setResolver(null);
  };

  const onConfirm = () => {
    setLoading(true);
    resolver?.(true);
    closeDialog();
  };

  const onCancel = () => {
    setLoading(true);
    resolver?.(false);
    closeDialog();
  };

  return {
    getUserConfirmation,
    confirmationDialog: (
      <ConfirmationModal
        open={hasPending}
        onConfirm={onConfirm}
        onCancel={onCancel}
        title={title}
        loading={loading}
      >
        {bodyText}
      </ConfirmationModal>
    ),
  };
};
```

Now our UI can await user input without cluttering the component with modal state. ğŸš€

## ğŸ’» Step 2: Use It Anywhere

```tsx
const ConfirmButton = () => {
  const { getUserConfirmation, confirmationDialog } = useConfirmationDialog();

  const handleClick = async () => {
    const confirmed = await getUserConfirmation({
      title: 'Delete item?',
      bodyText: 'Are you sure you want to delete this item?',
    });
    if (confirmed) {
      // Proceed
    }
  };

  return (
    <>
      <button onClick={handleClick}>Delete</button>
      {confirmationDialog}
    </>
  );
};
```

This lets us declaratively render the dialog when needed and keep imperative logic readable. ğŸ§µ

# ğŸŒ Beyond Yes/No

This pattern isnâ€™t just for simple confirmations. We can build prompts for different types of questions:

* **Yes/No**: "Do you want to continue?"
* **Multiple Choice**: "Whatâ€™s your favorite food?" with options like Pizza, Sushi, Tacos.
* **Text Input**: "What should we call this project?"
* Anything else really...

All of these can follow the same structure:

1. Start a Promise.
2. Render a modal.
3. Resolve the Promise with the userâ€™s answer.

The UI gets to *ask*, and our logic gets to *wait* for an answer. â³

There are many ways to abstract this for more generalization. On example could be to provide an interface
to ask different `type`s of questions, as follow:

```tsx
const answer = await prompt({
  type: 'multipleChoice',
  message: 'Whatâ€™s your favorite food?',
  options: ['Pizza', 'Sushi', 'Tacos'],
});
```

Or:

```tsx
const name = await prompt({
  type: 'text',
  message: 'What should we name this project?',
  placeholder: 'Enter project name...',
});
```

Each variation maps to a reusable, typed modal component that knows how to ask that kind of question and resolve the correct shape of answer. ğŸ§ª

This is generally useful for anytime we need to open up a temporary prompt, no matter how simple or complex, to
get a user input, then let the main component handle the result of the prompt. ğŸ§ 

# ğŸ§¼ Why This Pattern Matters

This technique is a declarative wrapper over imperative logic. We get to write clean, sequential logic (`if (confirmed)`) while still keeping modal logic centralized and decoupled. ğŸ”„

Itâ€™s testable, composable, and scales well. Itâ€™s not limited to confirmation modalsâ€”we can extend this to file pickers, form modals, password prompts, and more. ğŸ”‘

# ğŸ Wrap-Up

**Async prompts** flip the script: instead of our UI reacting to state changes, it gets to ask questionsâ€”and *wait* for answers.

We keep our components clean. Our logic stays linear. No tangled modal state or boilerplate everywhere. Just clear, declarative questions rendered at the right time, with answers that resolve like magic.

If youâ€™ve ever wished `window.confirm` worked like a React component, this pattern is for you.
