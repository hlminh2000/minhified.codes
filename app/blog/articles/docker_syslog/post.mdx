---
title: Managing Docker Container Logs through Linux Syslog
date: 2025-01-07
preview: |
  If you ever find yourself having to maintain long-running docker containers in a linux host,
  capturing and managing container logs can be a tricky task. This article might provide a hint.
image: ./docker_syslog_2.jpeg
---

# tldr
- When running Docker containers on bare linux OS, generating and managing log files for containers 
is best done by the host machine, not the application container.
- This can be achieved by:
  1. Configure Docker daemon to use `syslog` driver
  1. Configure `rsyslog` to direct logs to separate file
  1. Configure log rotation with `logrotate`
- In practice, unless there's a special needs, such as interfacing with specialized hardware,
it's not a good idea to run Docker in bare linux machines in production. If you're building a new 
application in 2025, please consider:
  - A serverless model (maybe something like Next.JS with Vercel / Netlify)
  - A container orchestration service (such as AWS's ECS or ELK, or Kubernetes on GCP)

# The problem

Due to specialized hardware requirement, a system I inherited was only deployable on bare-metal
Linux boxes. As any long-running service goes, being able to capture and rotate logs were crucial
in the operation of such system. Here's are basic requirements:
- The logs must be **captured in disk for archiving**
- The log files must be **rotated periodically and removed** from disk to avoid build-up
- The log file **content must follow a consistent format** to be parsed by reporting system

There were multiple application components, each running in its own Docker container. To achieve
the above goals, the original system had the applications implement these logging logics, either 
through logging libraries (such as `winston` for Node.js applications, and the `logging` module
for Python), or a fully custom implementation in the case of C/C++. A common volumn was then mounted
on all logging containers to capture the logs generated. This presents a few problems:
 1. Inconsistent implementation across different applications
 1. Additional complexities in application requiring developer attention
 1. Operator did not have direct control over the log rotation policy
 1. The log management is tied to container's life, so if a container is having issue starting,
 its logs may never get rotated

Over time, this was clearly not a sustainable solution. This post outlines one solution we've settled
on.

# The solution

Instead of leaving it to the applications to implement these logging logic, it's possible to simply let
the appplication log to standard IO, then handle the rest at the host OS through 
[`syslog`](https://en.wikipedia.org/wiki/Syslog).

***Note:*** I operate mostly on Ubuntu servers, the specific for your flavour of Linux might differ.

To do this, we need to:

### 1. Configure Docker daemon to use `syslog` driver:
My Docker daemon config was found at `/etc/docker/daemon.json`. I editted this to something like so:
  ```json
  {
    // ... other configs
    "log-driver": "syslog",
    "log-opts": {
      "syslog-address": "unixgram:///dev/log",
      "tag": "docker_containers.log",
      "syslog-facility": "daemon"
    }
  }
  ```
Here we are specifying:
- `log-driver` tells Docker which logging driver to use, in this case, `syslog`
- `log-opts` includes the specific configuration for the driver [as documented here](https://docs.docker.com/engine/logging/drivers/syslog/#options).
In this case, we have:
  - `syslog-address`: specify that we want to use the host machine's standard system logging entry point
  at `/dev/log`. Theoretically, a remote syslog server that implements the `syslog` protocol over `tcp`
  or `udp` can also be used.
  - `tag`: a tag to attach to each log line. This will help us direct the logs to the right file later.
  - `syslog-facility`: see [Wikipedia](https://en.wikipedia.org/wiki/Syslog#Facility)

Once updated, restart the docker service as so:
  ```bash
  sudo systemctl restart docker
  ```
Once my containers were back, I can now see my Docker containers logging to `/var/log/syslog`, by following it
like so:
  ```bash
  sudo tail -f /var/log/syslog
  ```
One quick way to test this is to run an `echo` command in an ephemeral container, like so:
  ```bash
  docker run -it bash "echo hello"
  ```

### 2. Configure `rsyslog` to direct logs to separate file
To separate the container logs from the rest of your host machine's syslog, it's a good idea to direct 
container logs to a file separate from `/var/log/syslog`.

The folder `/etc/rsyslog.d` contains rsyslog configurations for log processing rules. We can start with creating
a new configuration file, say `docker-containers.conf` with the command:
  ```bash 
  sudo touch /etc/rsyslog.d/docker-containers.conf
  ```
Edit this file to look something like so:
  ```conf
  $template DockerContainerLogs,"/var/log/%syslogtag"

  if $syslogtag contains 'docker_containers.log'  then -?DockerContainerLogs

  & stop
  ```
Here `$syslogtag` corresponds to to the `log-opts.tag` configured in the `/etc/docker/daemon.json` config earlier.

Once the update is complete, `rsyslog` needs to be restarted like so:
  ```bash
  sudo systemctl restart rsyslog
  ```

We now have all docker container logs being captured in `/var/log/docker_containers.log`.  I kept it simple by piping 
everything into one file, but it is possible to include further splitting by attaching the container names and other info 
on the file name.

### 3. Configure log rotation
If we leave things as is, the `docker_containers.log` file will continue to grow indefinitely, eventually taking up
all the disk space in our host machine. To prevent this, we can configure periodic rotation the content of 
`docker_containers.log` into a new file and empty out `docker_containers.log`.

This can be achieved by configuring `logrotate`. The configuration is typically broken down into multiple
files under `/etc/logrotate.d`, so I created a new file `/etc/logrotate.d/docker-containers`, which looks
like so: 
```
/var/log/containers/docker_containers.log {
    daily
    rotate 7
    create 0640 syslog adm
    missingok
    notifempty
    postrotate
        /usr/lib/rsyslog/rsyslog-rotate
    endscript
}
```
This configuration effectively says: 
  - rotate docker_containers.log daily, 
  - keep 7 files worth of past log,
  - create new files with `0604` permission, under `syslog adm` ownership, 
  - skip the operation if the file is missing or empty

Overtime, we will have files like so:
```bash
minhified@host:~$ ll /var/log/ | grep docker_containers.log
-rw-r-----  1 syslog adm        33305 Jan  8 11:10 docker_containers.log
-rw-r-----  1 syslog adm         7588 Jan  8 00:00 docker_containers.log.1
-rw-r-----  1 syslog adm         8531 Jan  7 00:00 docker_containers.log.2
-rw-r-----  1 syslog adm         7120 Jan  6 00:00 docker_containers.log.3
-rw-r-----  1 syslog adm         7107 Jan  5 00:00 docker_containers.log.4
-rw-r-----  1 syslog adm         8243 Jan  4 00:00 docker_containers.log.5
-rw-r-----  1 syslog adm         7109 Jan  3 00:00 docker_containers.log.6
-rw-r-----  1 syslog adm         7141 Jan  2 00:00 docker_containers.log.7
```
This would allow us to operate on old logs without impacting the main `docker_containers.log` file.
More intricate configurations can also be applied, such as specifying a size cutoff for the log file
in addition to / instead of the periodical rotation. See [this](https://betterstack.com/community/guides/logging/how-to-manage-log-files-with-logrotate-on-ubuntu-20-04/) 
for more details.

Additionally, options such as `prerotate` and `postrotate` also allows for performing custom operations
on the rotate log files, such as pushing notifications, moving to cold-storate like S3, etc...

### 4. Some Caviats
One issue I ran into was that, depending on how the application is ran inside the container, 
the logs may not be captured by the container's console properly. In order for the container
logs to be captured by syslog, it must be directed to the container's console. There are two
ways this may be achieved:

  1. Ensure that the main application process has a PID of 1, since this is the PID that gets
  monitored. Tools such as [`tinit`](https://github.com/krallin/tini) can help with this. However,
  this may not always be achievable, so

  1. Run the container with TTY enabled. Without going into details about what TTY is, this ensures
  that any log that results from the main `command` in the container gets directed to the console.
  This can be achieved with either:
      - `docker run -t ...` if you are running containers with `docker` directly, or
      - including `tty: true` in the service definition in your `docker-compose.yaml` file

# Conclusion

